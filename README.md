### This is a recognition project with conventional ml method!
功能定义

配置表
1. 根据不同的要求选择合适的配置参数表；预先将可选择的参数配置表载入，
   然后根据条件从中选择一种配置方式。
2. 可接收实时刷新的参数配置；不预先加载所有配置，配置可以实时更改的，
   每次都使用最新的配置。
3. 每个处理器都有一个都有一个参数属性，该参数接受更改，更改的接口是
   参数的修改的方法，外部程序只能通过调用方法的方式去更改参数，而不
   是直接更改参数。
4. 每次根据对象的引用使用参数的方式，相当于实时对参数进行追踪。
5. 参数更新的方式：<1> 根据消息内容更改，处理器自身进行更改，或者由
   消息拦截器进行更改，<2> 根据条件更改，外界调用更新接口进行更改，
   <3> 外界不调用接口进行更改，这种方式是不建议的，会出现意外，除非
   外界程序不能使用该种语言接口！总之，就是通过共享数据的方式，不同
   端分别对数据进行更新或者获取，通过共享数据进行交互。
   
实现机制
1. 由于相互依赖较多，依赖趋于复杂，构成复杂的拓扑网络，若按照通常的编写
   方式，是需要将执行流程写死在代码中，过于复杂的话，难以理清先后关系，
   若不能理清执行逻辑的话，程序的前后依赖得不到满足，程序无法继续。因此，
   通常的编写方式，逻辑的拓展性弱。除非程序块之间是较强的结构关系，可以
   考虑直接引用的方式，毕竟他们是个功能的形成整体，这种关系比较稳定，就像
   是人总会由手脚一样。通过直接调用的方式来进行依赖处理具体分为几种：
   <1> 直接call对象的名字 <2> 通过对象的地址，访问调用对象。
2. 可以通过图的方式指定相互依赖关系，程序编写，主要是描述相互依赖关系，并
   将这种关系形成数据结构进行解析，得到执行的逻辑，这个就是相当于抽象了执行
   流程并求解，根据求解结果执行；很显然，这需要更通用的数据结构，因为依赖之间
   能够接受的数据类型是不能提前知道的，或者是一种通用的大家都知晓的类型，均能使用计算，
   或者程序在入口检查数据类型，只准许目标类型进入，特别是动态语言，不能在
   编译时而只能在运行时进行类型检查，因为类型变得通用后，并不能完全保证进入
   程序的数据类型一定符合特定的要求；不像通常的编写方式，进入程序的类型，
   在认为编写的逻辑下，得到了很好的控制，数据类型导致的意外大大降低，因此，
   关于检查的意义。
3. 观察者模式或者其他的注册监听的模式，通常也是固定到特定监听源，灵活程度也是有限的。
   本处不采用观察者的方式，而是在其中再次抽象出一层。
4. 处理的依赖问题的其他方式，还包括共享数据，如队列和共享内存块的方式，需要通信的模块
   之间，通过对数据区域的读写达到交换数据的目的。如何更好的完成双向通信也是个问题。
5. 通过发送消息的模式，每个模块都有通讯能力，既可以接收到消息，也可以发送出消息，由第三方进行
   消息的路由，这样似乎可以完成双向通信。
6. 程序直接维护依赖关系，包括几种编写程序的范式，像责任链那种模式也需要处理程序
   自己去维护依赖关系。另一种方式，是由第三方类维护这种依赖关系，第二条讨论的模式也算是
   这种方式，依赖关系由第三方维护，而不是在另外起一个模块通过写死的方式维护，总之所谓的依赖，
   就是二者之间的通信，在合适的情景需要选择合适的方式来解决这个问题，而不是一种方式到底。
   参考tornado的风格。采用server的模式。

选择的机制
1. 一个生产者可以向多个Topic发送消息，一个消费者也可以同时从几个Topic接收消息。
   同样的，一个Topic也可以被多个消费者来接收消息。

2. 为了实现多进程并行，并且其中有进程通信的问题。需要解决。
3. 特别是多进程共同写一个文件，会有问题产生，本处的考虑使用单一进程来完成写操作。
4. 以上实现了进程之间的数据共享，不是数据传递，而是真正的共享。并且可以同时修改。

Manager()内部有加锁机制，不允许两个进程同时修改一份数据，因为进程的数据是独立的。

python 多进程数据交互及共享
多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。

不同进程之间内存是不共享的，要实现两个进程间的数据交换，可以用以下方法：
