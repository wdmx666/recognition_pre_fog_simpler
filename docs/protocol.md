#### 使用操作系统通信的数据分析应用(FoG)
##### 实现进程间数据通信(共享)的机制


通信机制

1. 使用一个服务器等待接收消息，并将根据消息头，将其路由给特定的处理器；
2. 使用一个程序将消息整理好，并不断的向服务器发出消息；
3. 本程序，服务器监听文件夹(模拟队列)，从文件夹中获取消息；该消息触发处理器。
4. 使用操作系统来存放消息的内容，能够有效处理进程间数据共享问题。
5. 本应用采用单个线程来模拟信息的收发，本处的消息源，既可以看做消息源，又可以看做server,
   还可以看做中介者，请注意与这些范式相比较。很多时候这些名称指向的都是同一个东西，只是从
   不同的角度的出来的结论。
6. 消息源是一个相对的概念，对于处理器来说获得信息的地方就是它的直接信息源，不管他是从中介还是
   直接获得消息。

   
协议编制
1. 第一，所有的处理器全部只注册到特定的信息上去，并不注册到消息源上去，完全是消息驱动，
   这样避免了与源的耦合性。
2. 第二，所有消息的基本信息头，基本全部放入一个消息队列(集合)，而消息的内容可不放在队列中，
   因为有的消息体非常大，消息中带有内容的引(URL,定位符，根据它能够获取到消息的body.);
   将消息放在一个队列中，有几点好处，可以对队列中的消息进行计算，比如排序，去重等运算，根据
   协议还可以控制程序以流程同步或者异步的方式来运行。
3. 可以使用专门的进程(线程)来管理消息，使消息不至于让多个线程来管理，避免混乱。
4. 采用每个处理器完成一次工作之后向消息中心发送通知消息，而不是直接向下游的处理器发送消息，
   这样利于管理和控制消息的收发，解除每个处理器都过多处理消息的问题，另一方面还有消息安全性问题，
   通过消息中心可以保证处理器之间消息能够确保到达，而不会出现因未及时收到而导致的丢失，也能够避
   免直接发送时接收处理器处理不及的问题。
5. 简单消息协议指定： 如从节点node1发送序号为ID的消息到node3,并且可以带上简单的消息内容
   如文件名称等，该简单协议是根据约定位置的含义来包装与解析消息,可以表示为：
   node1=node3=ID=content1，还有 node2=node3=ID=content2，node2也向node3发送相同ID不同内容
   的消息，这种表象会有几种具体不同场景，以数据分析流程为例进行说明:
   <1> node1与node2是对同一个序号的来源数据的两种类似但不同的处理，处理之后，均可以发送给node3,
   独立处理。<2> node1与node2是对同一个序号的来源数据的两种类似但不同的处理，处理之后，发送给node3,
   共同处理，node3需要node1和node2同ID的消息才能处理。就发送的消息内容来说不能分辨出这种依赖关系，
   节点应该只需要将消息发送出去即可。这种依赖关系需要使用一个依赖关系表来维护，消息中心根据这个表
   来进行调度。
6. 消息中心及时收取消息，并处理掉已使用过的消息；消息中心不是仅仅做一下消息的转发，而会对对消息
   进行运算，如常见的排序，优先级，保序，依赖同步等；特别是依赖同步发送，如node3依赖node1和node2，
   nod3需要同一个ID的来自node1和node2的消息才能处理，单独node1和node2的消息对node3来说意义不大，
   因为nod3仍然无法处理，这需要消息中心将依赖同步后一同发送过来让node3处理。每个处理器的hooker
   需要知道它对应的处理器被哪些处理器依赖了，并向它们发送消息；若处理器及其对应hooker仅仅是接收消息
   计算并存储产生的消息，而是让一个程序专门监控消息体再去构造消息，会把事情搞得更复杂。
7. 根据消息动态创建(或从池中挑选)特定运算程序的进程(线程)运行，而不是在一开始就为每个处理器创建好进程(线程)，
   这样可避免进程的空闲，充分利用进程资源。

应用架构
1. 本程序在处理器的基础上抽象出一个称为pipe的结构，这个结构里的程序都是按照顺序同步执行的，正如直管一样，
   这个结构表示一个独立的任务，是应用程序依赖的基本单元，也是并行执行的基本单元。管道可以有多个处理器，
   也可以只有一个。管道需要构建传递参数等工作，因此在管道的基础上包装一个称为任务的客户端，以这个为应用运行
   的基本单元和任务依赖的单元和并行的单元，在此基础构建依赖。所有消息从管道口进入在其中经过hooker和处理器，
   最终发送一个出去管道的消息。
2. 由于涉及到进程间共享数据，考虑几种通信机制；如特殊的能共享的数据结构，管道，TCP/HTTP等，队列，数据库，
   操作系统等；本应用选择使用操作系统；本应用采用间接通讯机制，不采用直接的通信方式，如直接调用或者通过TCP等
   直接向某个节点发送消息，本应用采用通信中心的方式来进行通讯，有它进一步处理消息。
3. 本应用采用处理器与它Hooker分开的方式进行管理，Hooker主要是用来打杂的。
4. 采用中间层的目的，可以缓存中间结果避免下次再次请求时重新计算返回，这样可以减少工作量和服务器的压力。本应用
   采用服务器文件系统作为缓存。


讨论

1. 任务是并行的基本单位，而进程(甚至是连个独立的应用程序)间通信，靠共享文件，数据库，TCP等。
2. 本应用采用共享文件的方式进行。若将消息的本体内容通过socket之类传递过来，会占用大量资源，
   a. 长时间占用通信资源，b. 对象需要序列化后再传输，从一个应用程序传递到另一个应用程序，
   c.当两个文件对象在同一个操作系统上时，根本不需要传输消息的本体内容，只要告诉一个地址直接
   去取就好。
3. 采用通过消息头的方式，有点异步传输的味道，或者异步请求的味道，发送程序只需要发送告知信息就返回，
   而接收程序就收之后，可以异步处理消息，而这里本质是异步接收。就先收发快递一样，快递员一样，
   快递员短信通知说物品放在了XX位置的菜鸟驿站，请自取。如，一个程序，主线程发送(传入)url之后返回，
   然后让后面线程慢慢去下载。异步消息，通知消息确实是异步发送消息队列的，处理是不同步的。
   也就是和传递文件一样，A不之间将B文件传给B,而是告诉他文件的位置让他自己去下载。
4. 处理不同应用和系统之间的同步情况，不能再A应用没有完成操作的情况下去占用同一个资源，特别是在
   异步处理的情况下。
