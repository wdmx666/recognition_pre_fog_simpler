"""
use the Processor to make task,maybe several Processors are needed!
处理任务之间的依赖问题的方式：
<1> 在被调用时，被调任务主动检查其结果是否准备好，若准备好，直接返回结果地址，否则重新计算并返回地址，无论如何，主调任务都
不知道被调任务是怎么干的，对它是透明的，它只需要拿到它想要的结果地址就好，理论上主调程序不应该做这种逻辑。
<2> 主调任务主动去检查其依赖结果的固定位置检查结果是否存在(每个任务都这么去做，流程就会流动起来;被调任务也需要往固定位置写)，
若未准备好，则去通知或调用被调任务；这是个悖论，所有任务都去检查结果，就不会无结果，除非它条件不满足，这样的话调用也没用。
若每个任务都主动去检查的话，那就得每个任务的进程都活着，否则不可能去检查条件是否满足，所以主要看采用是什么样的架构。本应用
不采用服务架构。
<3> 当被调任务被调用时，它自己不去检查主调的依赖它当前是否满足了，而是去交给另外的调度程序来管理，每个任务都提供这样一些
接口给调度程序使用！任务自己不应该维护自己的任务是否已经存在这件事？而是让第三方去维护？任务之间完全透明。
不采用注入任务，然后调用方式。模板代码可以提取出来形成新的逻辑层。
<4> Luigi的调度层遵循先检查输出，若输出存在则不去检查任务的依赖，更不会去计算，若不存在则去检查依赖的状况，检查依赖任务的输出，
在检查依赖任务的依赖，递归的进行下去.
<5> 若仍采用传统调用模式，可以先刻画各任务的依赖图加上缓存的方式。任务级别需要这种调度，processor级别不需要。
<6> 采用多个线程服务的形式来做，一个线程一个服务。
<7> 必须得对依赖的输出有所了解，后面处理才能采取正确的形式,这是一种弊端，采用统一形式则不会出现.
以依赖的形式进行调用，一个任务中调用另一个任务很突兀，两者谁也不属于谁，强放意义不合适。
专门的调度程序来控制任务的执行，不由任务之间的调用。为了避免采用加层来解决这个问题，
本处采用直接调用的方式来解决依赖。
也可以采用每个任务检查其条件是否满足，控制程序的执行，使用文件夹(队列也可当管道，缓存呢)当做管道来解决依赖问题
搞到现在发现我需要的是一个管道。

"""